#!/usr/bin/env python3
"""Install packages when package configuration changes."""

import sys
import subprocess
import shutil
from pathlib import Path

def detect_package_managers():
    """Detect available package managers on the current system."""
    managers = {}

    # Check for common package managers
    if shutil.which("brew"):
        managers["brew"] = True
        managers["cask"] = True  # cask is part of brew
    if shutil.which("apt"):
        managers["apt"] = True
    if shutil.which("winget"):
        managers["winget"] = True
    if shutil.which("scoop"):
        managers["scoop"] = True
    if shutil.which("dnf"):
        managers["dnf"] = True
    if shutil.which("pacman"):
        managers["pacman"] = True
    if shutil.which("snap"):
        managers["snap"] = True

    return managers

def run_command(command, description):
    """Run a command and return success status."""
    try:
        print(f"Running: {description}")
        print(f"Command: {' '.join(command)}")

        result = subprocess.run(
            command,
            check=True,
            capture_output=True,
            text=True
        )

        if result.stdout:
            print(f"Output: {result.stdout.strip()}")
        return True

    except subprocess.CalledProcessError as e:
        print(f"Error running {description}: {e}")
        if e.stderr:
            print(f"Error output: {e.stderr.strip()}")
        return False
    except FileNotFoundError:
        print(f"Command not found for {description}: {command[0]}")
        return False

def install_packages_with_manager(manager, packages):
    """Install packages using the specified package manager."""
    if not packages:
        return

    print(f"\n=== Installing packages with {manager} ===")

    # Define installation commands for each manager
    install_commands = {
        "brew": ["brew", "install"],
        "cask": ["brew", "install", "--cask"],
        "apt": ["sudo", "apt", "install", "-y"],
        "winget": ["winget", "install", "--accept-source-agreements", "--accept-package-agreements"],
        "scoop": ["scoop", "install"],
        "dnf": ["sudo", "dnf", "install", "-y"],
        "pacman": ["sudo", "pacman", "-S", "--noconfirm"],
        "snap": ["sudo", "snap", "install"],
    }

    if manager not in install_commands:
        print(f"Unknown package manager: {manager}")
        return

    base_command = install_commands[manager]

    # Install packages one by one for better error handling
    for package in packages:
        command = base_command + [package]
        success = run_command(command, f"Installing {package} with {manager}")

        if not success:
            print(f"Failed to install {package}, continuing with next package...")

def simple_yaml_parse(content):
    """Simple YAML parser for our specific package format."""
    result = {}
    current_section = None

    for line in content.split('\n'):
        line = line.strip()

        # Skip empty lines and comments
        if not line or line.startswith('#'):
            continue

        # Check for section headers (e.g., "packages:" or "  brew:")
        if line.endswith(':'):
            key = line[:-1].strip()
            if key == 'packages':
                continue  # Skip the top-level packages key
            elif line.startswith('  '):  # Indented section (package manager)
                current_section = key
                result[current_section] = []
            continue

        # Check for list items (e.g., "    - git")
        if line.startswith('- ') and current_section:
            package = line[2:].strip()
            result[current_section].append(package)

    return result

def main():
    """Main entry point."""
    # Load packages from chezmoidata
    packages_data = {{ .packages | toJson }}

    # Detect available package managers
    available_managers = detect_package_managers()

    if not available_managers:
        print("No supported package managers found on this system.")
        return

    print(f"Available package managers: {', '.join(available_managers.keys())}")

    # Install packages for each available manager
    for manager, package_list in packages_data.items():
        if manager in available_managers:
            install_packages_with_manager(manager, package_list)
        else:
            print(f"\nSkipping {manager} (not available on this system)")
            if package_list:
                print(f"  Would have installed: {', '.join(package_list)}")

    print("\n=== Package installation complete ===")

if __name__ == "__main__":
    main()
